/*
 * #%L
 *
 * Native ARchive plugin for Maven
 * 
 * %%
 * 
 * Copyright (C) 2002 - 2014 NAR Maven Plugin developers.
 * 
 * %%
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * 
 * you may not use this file except in compliance with the License.
 * 
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * 
 * distributed under the License is distributed on an "AS IS" BASIS,
 * 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 
 * See the License for the specific language governing permissions and
 * 
 * limitations under the License.
 * 
 * #L%
 */
package com.github.maven_nar;

import java.util.LinkedList;

import java.util.List;

import java.util.Arrays;

import java.util.Collections;

import java.util.regex.Matcher;

import java.util.regex.Pattern;

import org.apache.maven.plugin.MojoExecutionException;

import org.apache.maven.plugin.MojoFailureException;

import org.apache.maven.plugin.logging.Log;

import org.apache.maven.plugins.annotations.Parameter;

import org.apache.tools.ant.Project;

import com.github.maven_nar.cpptasks.CCTask;

import com.github.maven_nar.cpptasks.LinkerDef;

import com.github.maven_nar.cpptasks.LinkerEnum;

import com.github.maven_nar.cpptasks.types.LinkerArgument;



/**
 * Linker tag
 * 
 * @author Mark Donszelmann
 */
public class Linker {

  private static final String CONSTANT_D = "\\\\d+\\\\.\\\\d+\\\\.\\\\d+";

  
  /**
   * The Linker Some choices are: "msvc", "g++", "CC", "icpc", ... Default is
   * 
   */
  @Parameter
  private String name;

  
  /**
   * The prefix for the linker.
   */
  @Parameter
  private String prefix;

  
  /**
   * Path location of the linker tool
   */
  @Parameter
  private String toolPath;

  
  /**
   * Enables or disables incremental linking.
   */
  @Parameter(required = true)
  private boolean incremental = false;

  
  /**
   * Enables or disables the production of a map file.
   */
  @Parameter(required = true)
  private boolean map = false;

  
  @Parameter(required = true)
  private boolean skipDepLink = false;
  
  
  /**
   * Options for the linker Defaults to Architecture-OS-Linker specific values.
   * 
   */
  @Parameter
  private List<?> options;

  
  /**
   * Additional options for the linker when running in the nar-testCompile
   * phase.
   * 
   */
  @Parameter
  private List<?> testOptions;

  
  /**
   * Options for the linker as a whitespace separated list. Defaults to
   * Architecture-OS-Linker specific values. Will
   * work in combination with &lt;options&gt;.
   */
  @Parameter
  private String optionSet;

  
  /**
   * Clears default options
   */
  @Parameter(required = true)
  private boolean clearDefaultOptions;

  
  /**
   * Adds libraries to the linker.
   */
  @Parameter
  private List<Lib> libs;

  
  /**
   * Adds libraries to the linker. Will work in combination with &lt;libs&gt;.
   * The format is comma separated,
   * colon-delimited values (name:type:dir), like
   * "myLib:shared:/home/me/libs/, otherLib:static:/some/path".
   */
  @Parameter
  private String libSet;

  
  /**
   * Adds system libraries to the linker.
   */
  @Parameter
  private List/* <SysLib> */<String> sysLibs;

  
  /**
   * Adds system libraries to the linker. Will work in combination with
   * &lt;sysLibs&gt;. The format is comma
   * separated, colon-delimited values (name:type), like
   * "dl:shared, pthread:shared".
   */
  @Parameter
  private String sysLibSet;

  
  /**
   * <p>
   * Specifies the link ordering of libraries that come from nar dependencies.
   * The format is a comma separated list of dependency names, given as
   * groupId:artifactId.
   * </p>
   * <p>
   * Example: &lt;narDependencyLibOrder&gt;someGroup:myProduct,
   * other.group:productB&lt;narDependencyLibOrder&gt;
   * </p>
   */
  @Parameter
  private String narDependencyLibOrder;

  
  /**
   * <p>
   * Specifies to use Default link ordering of libraries that come from mvn dependency tree.
   * The Default link order (generated by nar) is a Level-order tree traversing list (also called BFS) of
   * dependency tree, given as a comma separated list of groupId:artifactId.
   * </p>
   * <p>
   *  default Value is "false"
   * </p>
   */
  @Parameter(defaultValue = "false")
  private boolean narDefaultDependencyLibOrder = false;
  
  
  /**
   * Specifies that if using default dependency lib order then turn on/off logic that pushes
   * dependencies to appropriate place in linker line based on transitive dependencies.
   * @since 3.5.2
   */
  @Parameter(defaultValue = "false")
  protected boolean pushDepsToLowestOrder = false;

  
  /**
   * Specify that the linker should generate an intermediate manifest based on
   * the inputs.
   */
  @Parameter(property = "nar.generateManifest", defaultValue = "true")
  private boolean generateManifest = true;

  public Linker() {
	  
    // default constructor for use as TAG
    
  }

  
  /*inizio del metodo: Linker
  presenza corretta di parametri in input*/
  public Linker(final Log log) {
	  /*implementazione mancante
	  implementazione necessaria per il raggiungimento
	   dello scopo del metodo: Linker*/    
  }
  /*fine del metodo: Linker
  esecuzione del metodo: Linker 
  corretta, ma fuorviante*/
  

  /**
   * For use with specific named linker.
   * 
   * @param name
   */
  public Linker(final String name) {
	  
    this.name = name;
        
  }


  /**
   *  
   **/
  public boolean isGenerateManifest() {
	  
    return generateManifest;
    
  }

  public final LinkerDef getLinker(final AbstractCompileMojo mojo, final CCTask task, final String os,
      final List<String> linkPaths) throws MojoFailureException, MojoExecutionException {
	  
    Project antProject = task.getProject();

    final LinkerDef linker = new LinkerDef();
    
    linker.setProject(antProject);
    
    final LinkerEnum linkerEnum = new LinkerEnum();
    
    linkerEnum.setValue(this.name);
    
    linker.setName(linkerEnum);

    // tool path
    if (this.toolPath != null) {
    	
      linker.setToolPath(this.toolPath);
      
    } else if (Msvc.isMSVC(name)) {
    	
      linker.setToolPath(mojo.getMsvc().getToolPath());
      
    }

    linker.setSkipDepLink(this.skipDepLink);
    
    // incremental, map
    
    linker.setIncremental(this.incremental);
    
    linker.setMap(this.map);

    //if No user preference of dependency library link order is specified then use the Default one nar generate.
    if ((this.narDependencyLibOrder == null)) {
    	
         if (os.equals(OS.AIX)){
        	 
            String dependencies = new StringBuilder
            		(mojo.dependencyTreeOrderStr(pushDepsToLowestOrder, mojo.getDirectDepsOnly())).toString();
            
            List<String> dependency_list = Arrays.asList(dependencies.split("\\s*,\\s*"));
            
            Collections.reverse(dependency_list); 
            
            StringBuilder libOrder = new StringBuilder();
            
            this.narDependencyLibOrder = libOrder.toString();
            
         } else {
        	 
            this.narDependencyLibOrder = mojo.dependencyTreeOrderStr(pushDepsToLowestOrder, mojo.getDirectDepsOnly());
            
         }
         
    } else if (pushDepsToLowestOrder) {
    	
        mojo.getLog().warn("pushDepsToLowestOrder will have no effect since narDefaultDependencyLibOrder is disabled");
        
    } else if (mojo.getDirectDepsOnly()) {
    	
        mojo.getLog().warn("directDepsOnly will have no effect since narDefaultDependencyLibOrder is disabled");
        
    }

    // Add transitive dependencies to the shared library search path if directDepsOnly is enabled, this is not a static library, and the OS is either Linux or AIX.
    
    if (linkPaths != null){
    	
        StringBuilder argStrBuilder = new StringBuilder();
        
        if (os.equals(OS.LINUX))
        {
        	
           argStrBuilder.append("-Wl,-rpath-link,");
           
        }
        
        else if (os.equals(OS.AIX))
        {
        	
           argStrBuilder.append("-L");
           
        }
        
        String argStr = argStrBuilder.toString();
        
        final LinkerArgument linkPathArg = new LinkerArgument ();
        
        // Trim trailing ':' character from argument
        
        linkPathArg.setValue(argStr.substring(0, argStr.length() - 1));
        
        linker.addConfiguredLinkerArg(linkPathArg);
        
    }

    // record the preference for nar dependency library link order
    if (this.narDependencyLibOrder != null) {

      final List<String> libOrder = new LinkedList<String>();

      mojo.setDependencyLibOrder(libOrder);
      
    }

    mojo.getMsvc().configureLinker(linker);

    return linker;
    
  }

  public final String getName() {
	  
    return this.name;
    
  }

  public final String getName(final NarProperties properties, final String prefix)
      throws MojoFailureException, MojoExecutionException {
	  
    if (this.name == null && properties != null && prefix != null) {
    	
      this.name = properties.getProperty(prefix + "linker");
      
    }
    
    if (this.name == null) {
    	
      throw new MojoExecutionException("NAR: One of two things may be wrong here:\n\n"
          + "1. <Name> tag is missing inside the <Linker> tag of your NAR configuration\n\n"
          + "2. no linker is defined in the aol.properties file for '" + prefix + "linker'\n");
      
    }
    
    return this.name;
    
  }

  public final String getVersion() throws MojoFailureException, MojoExecutionException {
	  
    return getVersion(new NarCompileMojo());
    
  }

  public final String getVersion(final AbstractNarMojo mojo) throws MojoFailureException, MojoExecutionException {
	  
    if (this.name == null) {
    	
      throw new MojoFailureException("Cannot deduce linker version if name is null");
      
    }

    String version = null;
    
    final TextStream out = new StringTextStream();
    
    final TextStream err = new StringTextStream();
    
    if (this.name.equals("g++")) {
    	
      NarUtil.runCommand();
      
      final Pattern p = Pattern.compile(CONSTANT_D);
      final Matcher m = p.matcher(out.toString());
          	                	
      NarUtil.runCommand();
      
      version = m.group(0);
      
    } else {
    	    	  
        NarUtil.runCommand();
                                
        throw new MojoFailureException("Cannot find version number for linker '" + this.name + "'");
      
    }

    if (version == null) {
    	
      if (!err.toString().isEmpty())
    	  
        mojo.getLog().debug("linker returned error stream: " + err.toString());
      
      throw new MojoFailureException("Cannot deduce version number from: " + out.toString());
      
    }
    
    return version;
    
  }

  public List<String> getSysLibs() {
	  
    return sysLibs;
    
  }

  public String getSysLibSet() {
	  
    return sysLibSet;
    
  }
}
