/*
 * #%L
 * Native ARchive plugin for Maven
 * %%
 * Copyright (C) 2002 - 2014 NAR Maven Plugin developers.
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */
package com.github.maven_nar;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Objects;
import java.util.Set;
import java.util.Vector;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.shared.artifact.filter.collection.ScopeFilter;
import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.Project;
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.StringUtils;

import com.github.maven_nar.cpptasks.CCTask;
import com.github.maven_nar.cpptasks.CUtil;
import com.github.maven_nar.cpptasks.CompilerDef;
import com.github.maven_nar.cpptasks.LinkerDef;
import com.github.maven_nar.cpptasks.OutputTypeEnum;
import com.github.maven_nar.cpptasks.RuntimeType;
import com.github.maven_nar.cpptasks.SubsystemEnum;
import com.github.maven_nar.cpptasks.VersionInfo;
import com.github.maven_nar.cpptasks.types.LibrarySet;
import com.github.maven_nar.cpptasks.types.LinkerArgument;

/**
 * Compiles native source files.
 * 
 * @requiresSession
 * @author Mark Donszelmann
 */
@Mojo(name = "nar-compile", defaultPhase = LifecyclePhase.COMPILE, requiresProject = true,
  requiresDependencyResolution = ResolutionScope.COMPILE)
public class NarCompileMojo extends AbstractCompileMojo {
  private static final String MANIFEST = ".manifest";

/**
   * Specify that the final manifest should be embedded in the output (default
   * true) or false for side by side.
   */
  @Parameter(property = "nar.embedManifest", defaultValue = "true")
  protected boolean embedManifest = true;

  /**
   * The current build session instance.
   */
  @Parameter(defaultValue = "${session}", readonly = true)
  protected MavenSession session;

  private void copyInclude(final Compiler c) throws IOException, MojoExecutionException, MojoFailureException {
    if (c == null) {
      return;
    }
    c.copyIncludeFiles(
        getMavenProject(),
        getLayout().getIncludeDirectory(getTargetDirectory(), getMavenProject().getArtifactId(),
            getMavenProject().getVersion()));
  }

  private void createLibrary(final Project antProject, final Library library)
      throws MojoExecutionException, MojoFailureException {
	  
    getLog().debug("Creating Library " + library);
    
    // configure task
    
    final CCTask task = new CCTask();
    
    task.setCommandLogLevel(this.commandLogLevel);
    
    task.setProject(antProject);

    task.setDecorateLinkerOptions(this.decorateLinkerOptions);

    // subsystem
    
    final SubsystemEnum subSystem = new SubsystemEnum();
    
    subSystem.setValue(library.getSubSystem());
    
    task.setSubsystem(subSystem);

    // set max cores
    
    task.setMaxCores(getMaxCores(getAOL()));

    // outtype
    
    final OutputTypeEnum outTypeEnum = new OutputTypeEnum();
    
    final String type = library.getType();
    
    outTypeEnum.setValue(type);
    
    task.setOuttype(outTypeEnum);

    // stdc++
    
    task.setLinkCPP(library.linkCPP());

    // fortran
    
    task.setLinkFortran(library.linkFortran());
    
    task.setLinkFortranMain(library.linkFortranMain());

    // If we are building a shared library on AIX and the user has specified a sharedObjectName, use it.
    
    if (getOS().equals(OS.AIX)) {
    	
       task.setSharedObjectName(sharedObjectName);
       
    }

    // object directory
    
    File objDir = new File(getTargetDirectory(), "obj");
    
    objDir = new File(objDir, getAOL().toString() + "-" + library.getType());
    
    objDir.mkdirs();
    
    task.setObjdir(objDir);

    // failOnError, libtool
    
    task.setFailonerror(failOnError(getAOL()));
    
    task.setLibtool(useLibtool(getAOL()));

    // runtime
    
    final RuntimeType runtimeType = new RuntimeType();
    
    runtimeType.setValue(getRuntime(getAOL()));
    
    task.setRuntime(runtimeType);

    // IDL, MC, RC compilations should probably be 'generate source' type
    // actions, seperate from main build.
    // Needs resolution of handling for generate sources.
    // Order is somewhat important here, IDL and MC generate outputs that are
    // (often) included in the RC compilation
    
    if (getIdl() != null) {
    	
      final CompilerDef idl = getIdl().getCompiler(Compiler.MAIN, null);
          	  
        task.addConfiguredCompiler(idl);
        
        task.createIncludePath().setPath(objDir.getPath()); // generated
                                                            // 'sources'
      
    }
    
    if (getMessage() != null) {
    	
      final CompilerDef mc = getMessage().getCompiler(Compiler.MAIN, null);
      
        task.addConfiguredCompiler(mc);
        
        task.createIncludePath().setPath(objDir.getPath()); // generated
                                                            // 'sources'
      
    }

    // Darren Sargent Feb 11 2010: Use Compiler.MAIN for "type"...appears the
    // wrong "type" variable was being used
    // since getCompiler() expects "main" or "test", whereas the "type" variable
    // here is "executable", "shared" etc.
    // add C++ compiler
    
    if (getCpp() != null) {
    	
      final CompilerDef cpp = getCpp().getCompiler(Compiler.MAIN, null);
      
        // Set FortifyID attribute
      
        cpp.setFortifyID(getfortifyID());
        
        cpp.setCommands(compileCommands);
        
        cpp.setDryRun(dryRun);
        
        task.addConfiguredCompiler(cpp);
      
    }

    // add C compiler
    if (getC() != null) {
    	
      final CompilerDef c = getC().getCompiler(Compiler.MAIN, null);
      
        // Set FortifyID attribute
        c.setFortifyID(getfortifyID());  
        
        c.setCommands(compileCommands);
        
        c.setDryRun(dryRun);
        
        task.addConfiguredCompiler(c);
      
    }

    // add Fortran compiler
    if (getFortran() != null) {
    	
      final CompilerDef fortran = getFortran().getCompiler(Compiler.MAIN, null);
      
        fortran.setCommands(compileCommands);
        
        fortran.setDryRun(dryRun);
        
        task.addConfiguredCompiler(fortran);
      
    }

    // add javah include path
    final File jniDirectory = getJavah().getJniDirectory();
    
    if (jniDirectory.exists()) {
    	
      task.createIncludePath().setPath(jniDirectory.getPath());
      
    }

    // add java include paths
    getJava().addIncludePaths(task, type);

    getMsvc().configureCCTask(task);

    final List<NarArtifact> dependencies = getNarArtifacts();
    
    List<String> linkPaths = new ArrayList<String>();

    // If we're restricting deps to direct deps ONLY then trim transitive deps
    if (directDepsOnly){
    	
      HashSet<String> directDepsSet = getDirectDepsSet(getVerboseDependencyTree());
      
      ListIterator <NarArtifact> depsIt = dependencies.listIterator();

      // Trim all deps from dependencies that are not in the directDepsSet, warn if they are found.
      
    }

    // add dependency include paths

    // add linker
    final LinkerDef linkerDefinition = getLinker().getLinker(this, task, getOS(), getAOL().getKey() + ".linker.", type, linkPaths);
    
    linkerDefinition.setCommands(linkCommands);
    
    linkerDefinition.setDryRun(dryRun);
    
    task.addConfiguredLinker(linkerDefinition);
    
    // add dependency libraries
    // FIXME: what about PLUGIN and STATIC, depending on STATIC, should we
    // not add all libraries, see NARPLUGIN-96
    
    final boolean skipDepLink = linkerDefinition.isSkipDepLink();
    if (((type.equals(Library.SHARED)))) {

      final List depLibOrder = getDependencyLibOrder();
      
      List depLibs = dependencies;

      // reorder the libraries that come from the nar dependencies
      // to comply with the order specified by the user

    }

    // Add JVM to linker
    getJava().addRuntime(task, getJavaHome(getAOL()), getOS(), getAOL().getKey() + ".java.");

    // execute
    try {
    	
      task.execute();
      
    } catch (final BuildException e) {
    	
      throw new MojoExecutionException("NAR: Compile failed", e);
      
    }

  }

  /**
   * List the dependencies needed for compilation, those dependencies are used
   * to get the include paths needed for
   * compilation and to get the libraries paths and names needed for linking.
   */
  @Override
  protected ScopeFilter getArtifactScopeFilter() {
    return new ScopeFilter(Artifact.SCOPE_COMPILE, null);
  }

  private List getSourcesFor(final Compiler compiler) throws MojoFailureException, MojoExecutionException {
    if (compiler == null) {
      return Collections.emptyList();
    }

    try {
      final List files = new ArrayList();
      final List srcDirs = compiler.getSourceDirectories();
      for (final Object srcDir : srcDirs) {
        final File dir = (File) srcDir;
        if (dir.exists()) {
          files.addAll(FileUtils.getFiles(dir, StringUtils.join(compiler.getIncludes().iterator(), ","), null));
        }
      }
      return files;
    } catch (final IOException e) {
      return Collections.emptyList();
    }
  }

  @Override
  public final void narExecute() throws MojoExecutionException, MojoFailureException {

    // make sure destination is there
    getTargetDirectory().mkdirs();

    // check for source files
    int noOfSources = 0;
    noOfSources += getSourcesFor(getCpp()).size();
    noOfSources += getSourcesFor(getC()).size();
    noOfSources += getSourcesFor(getFortran()).size();
      if(getOS().equals( OS.WINDOWS ) && getArchitecture().equals("amd64"))
      {
          noOfSources += getSourcesFor(getAssembler()).size();
      }

    if (noOfSources > 0) {
      getLog().info("Compiling " + noOfSources + " native files");
      for (final Library library : getLibraries()) {
        createLibrary(getAntProject(), library);
      }
    } else {
      getLog().info("Nothing to compile");
    }

    try {
      // FIXME, should the include paths be defined at a higher level ?
      copyInclude(getCpp());
      copyInclude(getC());
      copyInclude(getFortran());
    } catch (final IOException e) {
      throw new MojoExecutionException("NAR: could not copy include files", e);
    }

    getNarInfo().writeToDirectory(this.classesDirectory);
    
    if (replay != null) {
      File compileCommandFile = new File(replay.getOutputDirectory(), NarConstants.REPLAY_COMPILE_NAME);
      NarUtil.writeCommandFile(compileCommandFile, compileCommands);
      
      File linkCommandFile = new File(replay.getOutputDirectory(), NarConstants.REPLAY_LINK_NAME);
      NarUtil.writeCommandFile(linkCommandFile, linkCommands);
    }
  }

  public boolean isEmbedManifest() {
    return embedManifest;
  }

  private void getManifests(String generated, Vector<String> manifests) {
    // TODO: /manifest should be followed by the list of manifest files
    // - the one generated by link, any others provided in source.
    // search the source for .manifest files.
    if (getLinker().isGenerateManifest())
      manifests.add(generated + MANIFEST);
  }

}
