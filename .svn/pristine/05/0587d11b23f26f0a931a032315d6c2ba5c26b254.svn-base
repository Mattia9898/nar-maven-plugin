/*
 * #%L
 * 
 * Native ARchive plugin for Maven
 * 
 * %%
 * 
 * Copyright (C) 2002 - 2014 NAR Maven Plugin developers.
 * 
 * %%
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * 
 * you may not use this file except in compliance with the License.
 * 
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * 
 * distributed under the License is distributed on an "AS IS" BASIS,
 * 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * 
 * See the License for the specific language governing permissions and
 * 
 * limitations under the License.
 * 
 * #L%
 */
package com.github.maven_nar;

import java.io.File;

import java.util.Collections;

import java.util.HashMap;

import java.util.List;

import java.util.Map;

import java.util.Properties;

import org.apache.maven.artifact.Artifact;

import org.apache.maven.artifact.factory.ArtifactFactory;

import org.apache.maven.artifact.metadata.ArtifactMetadataSource;

import org.apache.maven.artifact.resolver.ArtifactNotFoundException;

import org.apache.maven.artifact.resolver.ArtifactResolutionException;

import org.apache.maven.artifact.resolver.ArtifactResolutionResult;

import org.apache.maven.artifact.resolver.filter.ArtifactFilter;

import org.apache.maven.artifact.resolver.filter.ExcludesArtifactFilter;

import org.apache.maven.artifact.versioning.VersionRange;

import org.apache.maven.execution.MavenSession;

import org.apache.maven.plugin.MojoExecutionException;

import org.apache.maven.plugin.MojoFailureException;

import org.apache.maven.plugins.annotations.Component;

import org.apache.maven.plugins.annotations.LifecyclePhase;

import org.apache.maven.plugins.annotations.Mojo;

import org.apache.maven.plugins.annotations.Parameter;

import org.apache.maven.plugins.annotations.ResolutionScope;

import org.apache.maven.project.MavenProject;

import org.apache.maven.shared.artifact.filter.collection.ScopeFilter;

import org.apache.maven.surefire.booter.ForkConfiguration;

import org.apache.maven.surefire.booter.SurefireBooter;

import org.apache.maven.surefire.booter.SurefireBooterForkException;

import org.apache.maven.surefire.booter.SurefireExecutionException;

import org.apache.maven.surefire.report.BriefConsoleReporter;

import org.apache.maven.surefire.report.BriefFileReporter;

import org.apache.maven.surefire.report.DetailedConsoleReporter;

import org.apache.maven.surefire.report.XMLReporter;

import org.apache.maven.toolchain.Toolchain;

import org.apache.maven.toolchain.ToolchainManager;

import org.codehaus.plexus.component.repository.exception.ComponentLookupException;

// Copied from Maven maven-surefire-plugin 2.4.3

/**
 * Run integration tests using Surefire. This goal was copied from Maven's
 * surefire plugin to accomodate a few things
 * for the NAR plugin:
 * <P>
 * 1. To test a jar file with its native module we can only run after the
 * package phase, so we use the integration-test phase.
 * </P>
 * <P>
 * 2. We need to set java.library.path to an AOL (architecture-os-linker)
 * specific value, but AOL is only known in the NAR plugin and thus cannot be
 * set from the pom.
 * </P>
 * <P>
 * 3. To have the java.library.path definition picked up by java we need the
 * "pertest" forkmode. To use this goal you need to put the test sources in the
 * regular test directories but disable the running of the tests by the
 * maven-surefire-plugin by setting maven.test.skip.exec to false in your pom.
 * </P>
 *
 * @author Jason van Zyl (modified by Mark Donszelmann, noted by DUNS)
 * @version $Id: SurefirePlugin.java 652773 2008-05-02 05:58:54Z dfabulich $
 *          Mods by Duns for NAR
 */
// DUNS, changed class name, inheritance, goal and phase
@Mojo(name = "nar-integration-test", defaultPhase = LifecyclePhase.INTEGRATION_TEST,
  requiresDependencyResolution = ResolutionScope.TEST)
public class NarIntegrationTestMojo extends AbstractDependencyMojo {
	
  private static final String SYSTEM_ROOT = "SystemRoot";

  
  // DUNS added because of naming conflict
  /**
   * Skip running of NAR integration test plugin
   */
  @Parameter(property = "skipNar")
  private boolean skipNar;

  
  // DUNS changed to nar. because of naming conflict
  /**
   * Set this to 'true' to skip running tests, but still compile them. Its use
   * is NOT RECOMMENDED, but quite
   * convenient on occasion.
   * 
   * @since 2.4
   */
  @Parameter(property = "skipNarTests")
  private boolean skipNarTests;

  
  // DUNS changed to nar. because of naming conflict
  /**
   * DEPRECATED This old parameter is just like skipTests, but bound to the old
   * property maven.test.skip.exec. Use
   * -DskipTests instead; it's shorter.
   * 
   * @deprecated
   * @since 2.3
   */
  @Deprecated
  @Parameter(property = "nar.test.skip.exec")
  private boolean skipNarExec;

  
  // DUNS changed to nar. because of naming conflict
  /**
   * Set this to true to ignore a failure during testing. Its use is NOT
   * RECOMMENDED, but quite convenient on
   * occasion.
   * 
   */
  @Parameter(property = "nar.test.failure.ignore")
  private boolean testFailureIgnore;

  
  /**
   * The base directory of the project being tested. This can be obtained in
   * your unit test by
   * System.getProperty("basedir").
   * 
   */
  @Parameter(property = "basedir", required = true)
  private File basedir;

  
  /**
   * The directory containing generated test classes of the project being
   * tested.
   */
  @Parameter(property = "project.build.testOutputDirectory", required = true)
  private File testClassesDirectory;

  
  /**
   * The directory containing generated classes of the project being tested.
   */
  @Parameter(property = "project.build.outputDirectory", required = true)
  private File classesDirectoryTestMojo;

  
  /**
   * The Maven Project Object
   */
  // DUNS, made private
  @Parameter(defaultValue = "${project}", readonly = true)
  private MavenProject project;

  
  /**
   * The classpath elements of the project being tested.
   */
  @Parameter(property = "project.testClasspathElements", required = true, readonly = true)
  private List classpathElements;

  
  /**
   * Additional elements to be appended to the classpath.
   * 
   * @since 2.4
   */
  @Parameter
  private List additionalClasspathElements;

  
  /**
   * Base directory where all reports are written to.
   */
  @Parameter(defaultValue = "${project.build.directory}/surefire-reports")
  private File reportsDirectory;

  
  /**
   * The test source directory containing test class sources.
   * 
   * @since 2.2
   */
  @Parameter(property = "project.build.testSourceDirectory", required = true)
  private File testSourceDirectory;

  
  /**
   * Specify this parameter to run individual tests by file name, overriding the
   * <code>includes/excludes</code> parameters. Each pattern you specify here
   * will be used to create an include pattern formatted like
   * <code>**&#47;${test}.java</code>, so you can just type "-Dtest=MyTest" to
   * run a single test called
   * "foo/MyTest.java". This parameter will override the TestNG suiteXmlFiles
   * parameter.
   */
  @Parameter(property = "test")
  private String test;

  
  /**
   * List of patterns (separated by commas) used to specify the tests that
   * should be included in testing. When not
   * specified and when the <code>test</code> parameter is not specified, the
   * default includes will be
   * <code>**&#47;Test*.java   **&#47;*Test.java   **&#47;*TestCase.java</code>.
   * This parameter is ignored if TestNG
   * suiteXmlFiles are specified.
   */
  @Parameter
  private List includes;

  
  /**
   * List of patterns (separated by commas) used to specify the tests that
   * should be excluded in testing. When not
   * specified and when the <code>test</code> parameter is not specified, the
   * default excludes will be <code>**&#47;*$*</code> (which excludes all inner
   * classes). This parameter is ignored if TestNG suiteXmlFiles are
   * specified.
   */
  @Parameter
  private List excludes;

  
  /**
   * List of System properties to pass to the JUnit tests.
   * 
   */
  @Parameter
  private Properties systemProperties;

  
  /**
   * List of properties for configuring all TestNG related configurations. This
   * is the new preferred method of
   * configuring TestNG.
   */
  @Parameter
  private Properties properties;

  
  /**
   * Map of of plugin artifacts.
   */
  @Parameter(property = "plugin.artifactMap", required = true, readonly = true)
  private Map pluginArtifactMap;

  
  /**
   * Map of of project artifacts.
   */
  @Parameter(property = "project.artifactMap", readonly = true, required = true)
  private Map projectArtifactMap;

  
  /**
   * Option to print summary of test suites or just print the test cases that
   * has errors.
   */
  @Parameter(property = "surefire.printSummary", defaultValue = "true")
  private boolean printSummary = true;

  
  /**
   * Selects the formatting for the test report to be generated. Can be set as
   * brief or plain.
   */
  @Parameter(property = "surefire.reportFormat", defaultValue = "brief")
  private String reportFormat;

  
  /**
   * Option to generate a file test report or just output the test report to the
   * console.
   * 
   */
  @Parameter(property = "surefire.useFile", defaultValue = "true")
  private boolean useFile;

  
  // DUNS changed to nar. because of naming conflict
  /**
   * When forking, set this to true to redirect the unit test standard output to
   * a file (found in
   * reportsDirectory/testName-output.txt).
   * 
   * @since 2.3
   */
  @Parameter(property = "nar.test.redirectTestOutputToFile")
  private boolean redirectTestOutputToFile;

  
  /**
   * Set this to "true" to cause a failure if there are no tests to run.
   * Defaults to false.
   *
   * @since 2.4
   */
  @Parameter(property = "failIfNoTests")
  private Boolean failIfNoTests;

  
  /**
   * Option to specify the forking mode. Can be "never", "once" or "always".
   * "none" and "pertest" are also accepted
   * for backwards compatibility.
   * 
   * @since 2.1
   */
  @Parameter(property = "forkMode", defaultValue = "once")
  private String forkMode;

  
  /**
   * Option to specify the jvm (or path to the java executable) to use with the
   * forking options. For the default, the
   * jvm will be the same as the one used to run Maven.
   * 
   * @since 2.1
   */
  @Parameter(property = "jvm")
  private String jvm;

  
  /**
   * Arbitrary JVM options to set on the command line.
   * 
   * @since 2.1
   */
  @Parameter(property = "argLine")
  private String argLine;

  
  /**
   * Attach a debugger to the forked JVM. If set to "true", the process will
   * suspend and wait for a debugger to attach
   * on port 5005. If set to some other string, that string will be appended to
   * the argLine, allowing you to configure
   * arbitrary debuggability options (without overwriting the other options
   * specified in the argLine).
   *
   * @since 2.4
   */
  @Parameter(property = "maven.surefire.debug")
  private String debugForkedProcess;

  
  /**
   * Kill the forked test process after a certain number of seconds. If set to
   * 0, wait forever for the process, never
   * timing out.
   * 
   * @since 2.4
   */
  @Parameter(property = "surefire.timeout")
  private int forkedProcessTimeoutInSeconds;

  
  /**
   * Additional environments to set on the command line.
   * 
   * @since 2.1.3
   */
  @Parameter
  private Map environmentVariables = new HashMap();

  
  /**
   * Command line working directory.
   * 
   * @since 2.1.3
   */
  @Parameter(property = "basedir")
  private File workingDirectory;

  
  /**
   * When false it makes tests run using the standard classloader delegation
   * instead of the default Maven isolated
   * classloader. Only used when forking (forkMode is not "none").<br/>
   * Setting it to false helps with some problems caused by conflicts between
   * xml parsers in the classpath and the
   * Java 5 provider parser.
   * 
   * @since 2.1
   */
  @Parameter(property = "childDelegation")
  private boolean childDelegation;

  
  /**
   * (TestNG only) Groups for this test. Only classes/methods/etc decorated with
   * one of the groups specified here will
   * be included in test run, if specified. This parameter is overridden if
   * suiteXmlFiles are specified.
   *
   * @since 2.2
   */
  @Parameter(property = "groups")
  private String groups;

  
  /**
   * (TestNG only) Excluded groups. Any methods/classes/etc with one of the
   * groups specified in this list will
   * specifically not be run. This parameter is overridden if suiteXmlFiles are
   * specified.
   *
   * @since 2.2
   */
  @Parameter(property = "excludedGroups")
  private String excludedGroups;

  
  /**
   * (TestNG only) List of TestNG suite xml file locations, seperated by commas.
   * Note that suiteXmlFiles is
   * incompatible with several other parameters on this plugin, like
   * includes/excludes. This parameter is ignored if
   * the "test" parameter is specified (allowing you to run a single test
   * instead of an entire suite).
   * 
   * @since 2.2
   */
  @Parameter
  private File[] suiteXmlFiles;

  
  /**
   * Allows you to specify the name of the JUnit artifact. If not set,
   * <code>junit:junit</code> will be used.
   * 
   * @since 2.3.1
   */
  @Parameter(property = "junitArtifactName", defaultValue = "junit:junit")
  private String junitArtifactName;

  
  /**
   * Allows you to specify the name of the TestNG artifact. If not set,
   * <code>org.testng:testng</code> will be used.
   * 
   * @since 2.3.1
   */
  @Parameter(property = "testNGArtifactName", defaultValue = "org.testng:testng")
  private String testNGArtifactName;

  
  /**
   * (TestNG only) The attribute thread-count allows you to specify how many
   * threads should be allocated for this
   * execution. Only makes sense to use in conjunction with parallel.
   * 
   * @since 2.2
   */
  @Parameter(property = "threadCount")
  private int threadCount;

  
  /**
   * (TestNG only) When you use the parallel attribute, TestNG will try to run
   * all your test methods in separate
   * threads, except for methods that depend on each other, which will be run in
   * the same thread in order to respect
   * their order of execution.
   * 
   * @todo test how this works with forking, and console/file output parallelism
   * @since 2.2
   */
  @Parameter(property = "parallel")
  private String parallel;

  
  /**
   * Whether to trim the stack trace in the reports to just the lines within the
   * test, or show the full trace.
   * 
   * @since 2.2
   */
  @Parameter(property = "trimStackTrace", defaultValue = "true")
  private boolean trimStackTrace = true;

  
  /**
   * Creates the artifact
   */
  @Component
  private ArtifactFactory artifactFactory;

  
  /**
   * For retrieval of artifact's metadata.
   */
  @Component
  private ArtifactMetadataSource metadataSource;

  
  /**
   * Flag to disable the generation of report files in xml format.
   * 
   * @since 2.2
   */
  @Parameter(property = "disableXmlReport")
  private boolean disableXmlReport;

  
  /**
   * Option to pass dependencies to the system's classloader instead of using an
   * isolated class loader when forking.
   * Prevents problems with JDKs which implement the service provider lookup
   * mechanism by using the system's
   * classloader. Default value is "true".
   * 
   * @since 2.3
   */
  @Parameter(property = "surefire.useSystemClassLoader")
  private Boolean useSystemClassLoader;

  
  /**
   * By default, Surefire forks your tests using a manifest-only jar; set this
   * parameter to "false" to force it to
   * launch your tests with a plain old Java classpath. (See
   * http://maven.apache.org/plugins/maven-surefire-plugin/examples/class-
   * loading.html for a more detailed explanation
   * of manifest-only jars and their benefits.) Default value is "true". Beware,
   * setting this to "false" may cause
   * your tests to fail on Windows if your classpath is too long.
   * 
   * @since 2.4.3
   */
  @Parameter(property = "surefire.useManifestOnlyJar", defaultValue = "true")
  private boolean useManifestOnlyJar = true;

  
  /**
   * By default, Surefire enables JVM assertions for the execution of your test
   * cases. To disable the assertions, set
   * this flag to <code>false</code>.
   * 
   * @since 2.3.1
   */
  @Parameter(property = "enableAssertions", defaultValue = "true")
  private boolean enableAssertions;

  
  /**
   * The current build session instance.
   */
  @Parameter(defaultValue = "${session}", readonly = true)
  private MavenSession session;

  private void addArtifact(final SurefireBooter surefireBooter, final Artifact surefireArtifact)
      throws ArtifactNotFoundException, ArtifactResolutionException {
	  
    final ArtifactResolutionResult result = resolveArtifact(null, surefireArtifact);

    for (final Object element : result.getArtifacts()) {
    	
      final Artifact artifact = (Artifact) element;

      getLog().debug("Adding to surefire booter test classpath: " + artifact.getFile().getAbsolutePath());

      surefireBooter.addSurefireBootClassPathUrl(artifact.getFile().getAbsolutePath());
      
    }
    
  }
  

  private SurefireBooter constructSurefireBooter() throws MojoExecutionException, MojoFailureException {
	  
    final SurefireBooter surefireBooter = new SurefireBooter();

    final Artifact surefireArtifact = (Artifact) this.pluginArtifactMap
        .get("org.apache.maven.surefire:surefire-booter");
    
    if (surefireArtifact == null) {
    	
      throw new MojoExecutionException("Unable to locate surefire-booter in the list of plugin artifacts");
      
    }

    surefireArtifact.isSnapshot(); 
    
    // this is ridiculous, but it fixes
    // getBaseVersion to be -SNAPSHOT if
    // needed

    
    try {
    	
      addArtifact(surefireBooter, surefireArtifact);

      
      // SUREFIRE-378, junit can have an alternate artifact name

      // this is pretty manual, but I'd rather not require the plugin >
      // dependencies section right now
      
      
    } catch (final ArtifactNotFoundException e) {
    	
      throw new MojoExecutionException("Unable to locate required surefire provider dependency: " + e.getMessage(), e);
      
    } catch (final ArtifactResolutionException e) {
    	
      throw new MojoExecutionException("Error to resolving surefire provider dependency: " + e.getMessage(), e);
      
    }

    // ----------------------------------------------------------------------
    //
    // ----------------------------------------------------------------------

    getLog().debug("Test Classpath :");

    // Check if we need to add configured classes/test classes directories here.

    // ----------------------------------------------------------------------
    // Forking
    // ----------------------------------------------------------------------

    final ForkConfiguration fork = new ForkConfiguration();

    fork.setForkMode(this.forkMode);

    processSystemProperties(!fork.isForking());

    if (fork.isForking()) {
    	
      this.useSystemClassLoader = this.useSystemClassLoader == null ? Boolean.TRUE : this.useSystemClassLoader;
      
      fork.setUseSystemClassLoader(this.useSystemClassLoader.booleanValue());
      
      fork.setUseManifestOnlyJar(this.useManifestOnlyJar);

      fork.setSystemProperties(this.systemProperties);

      fork.setJvmExecutable(this.jvm);
    	  
      this.argLine = "";

      final StringBuilder javaLibraryPath = new StringBuilder();
      final String narFile = "target/" + this.project.getArtifactId() + "-" + this.project.getVersion() + ".jar";
        
      getLog().debug("Adding to surefire test classpath: " + narFile);
      surefireBooter.addClassPathUrl(narFile);
      
      NarUtil.addLibraryPathToEnv(javaLibraryPath.toString(), this.environmentVariables, getOS());

      this.environmentVariables.put(SYSTEM_ROOT, NarUtil.getEnv(SYSTEM_ROOT, SYSTEM_ROOT, "C:\\Windows"));

      fork.setArgLine(this.argLine);
      fork.setEnvironmentVariables(this.environmentVariables);
      fork.setDebug(true);

      showMap(this.environmentVariables, "environment variable");
            
      this.enableAssertions = false;
      
    }

    surefireBooter.setFailIfNoTests(this.failIfNoTests == null ? false : this.failIfNoTests.booleanValue());

    surefireBooter.setForkedProcessTimeoutInSeconds(this.forkedProcessTimeoutInSeconds);

    surefireBooter.setRedirectTestOutputToFile(this.redirectTestOutputToFile);

    surefireBooter.setForkConfiguration(fork);

    surefireBooter.setChildDelegation(this.childDelegation);

    surefireBooter.setEnableAssertions(this.enableAssertions);

    surefireBooter.setReportsDirectory(this.reportsDirectory);

    return surefireBooter;
    
  }

  /**
   * List the dependencies needed for integration tests executions, those
   * dependencies are used to declare the paths
   * of shared and jni libraries in java.library.path
   */
  @Override
  protected ScopeFilter getArtifactScopeFilter() {
	  
    return new ScopeFilter( Artifact.SCOPE_TEST, null );
    
  }

  @Override
  protected File getUnpackDirectory() {
	  
    return getTestUnpackDirectory() == null ? super.getUnpackDirectory() : getTestUnpackDirectory();
    
  }

  /**
   * @return SurefirePlugin Returns the skipExec.
   */
  public boolean isSkipExec() {
	  
    return this.skipNarTests;
    
  }

  // DUNS, changed name
  @Override
  public void narExecute() throws MojoExecutionException, MojoFailureException {
	  
    if (this.skipTests || this.dryRun) {
    	
      getLog().info("Tests are skipped");
      
    } else if (verifyParameters()) {

      final SurefireBooter surefireBooter = constructSurefireBooter();

      getLog().info("Surefire report directory: " + this.reportsDirectory);

      int result;
      
      try {
    	  
        result = surefireBooter.run();
        
      } catch (final SurefireBooterForkException | SurefireExecutionException e) {
    	  
        throw new MojoExecutionException(e.getMessage(), e);
        
      }

      if (result == 0) {
    	  
        return;
        
      }
      
    }
    
  }

  protected void processSystemProperties(final boolean setInSystem) {
    if (this.systemProperties == null) {
      this.systemProperties = new Properties();
    }

    // We used to take all of our system properties and dump them in with the
    // user specified properties for SUREFIRE-121, causing SUREFIRE-491.
    // Not gonna do THAT any more... but I'm leaving this code here in case
    // we need it later when we try to fix SUREFIRE-121 again.

    // Get the properties from the MavenSession instance to make embedded use
    // work correctly
    
    final Properties userSpecifiedProperties = (Properties) this.session.getExecutionProperties().clone();
    
    userSpecifiedProperties.putAll(this.systemProperties);
    
    // systemProperties = userSpecifiedProperties;

    this.systemProperties.setProperty("basedir", this.basedir.getAbsolutePath());
    
    this.systemProperties.setProperty("user.dir", this.workingDirectory.getAbsolutePath());

    // DUNS, use access method rather than "localRepository" field.
    
    this.systemProperties.setProperty("localRepository", getLocalRepository().getBasedir());

    if (setInSystem) {
    	
      // Add all system properties configured by the user

      for (final Object o : this.systemProperties.keySet()) {
    	  
        final String key = (String) o;

        final String value = this.systemProperties.getProperty(key);

        System.setProperty(key, value);
        
      }
      
    }
    
  }

  private ArtifactResolutionResult resolveArtifact(final Artifact filteredArtifact, final Artifact providerArtifact)
      throws ArtifactResolutionException, ArtifactNotFoundException {
	  
    ArtifactFilter filter = null;
    
    if (filteredArtifact != null) {
    	
      filter = new ExcludesArtifactFilter(Collections.singletonList(filteredArtifact.getGroupId() + ":"
          + filteredArtifact.getArtifactId()));
      
    }

    final Artifact originatingArtifact = this.artifactFactory.createBuildArtifact("dummy", "dummy", "1.0", "jar");

    // DUNS, use access method rather than "localRepository" field.
    
    return this.artifactResolver.resolveTransitively(Collections.singleton(providerArtifact), originatingArtifact,
        getLocalRepository(), getRemoteRepositories(), this.metadataSource, filter);
    
  }

  /**
   * @param skipExec
   *          the skipExec to set
   */
  public void setSkipExec(final boolean skipExec) {
	  
    this.skipNarTests = skipExec;
    
  }

  private void showMap(final Map<String, String> map, final String setting) {
	  
    for (final Object o : map.keySet()) {
    	
      final String key = (String) o;
      
      final String value = (String) map.get(key);
      
      getLog().debug("Setting " + setting + " [" + key + "]=[" + value + "]");
      
    }
    
  }

  private boolean verifyParameters() throws MojoFailureException {
	  
    // DUNS
    if (this.skipNar || this.skipNarTests || this.skipNarExec) {
    	
      getLog().info("Tests are skipped.");
      
      return false;
      
    }

    if (!this.testClassesDirectory.exists()) {
    	
      if (this.failIfNoTests != null && this.failIfNoTests.booleanValue()) {
    	  
        throw new MojoFailureException("No tests to run!");
        
      }
      getLog().info("No tests to run.");
      
      return false;
      
    }

    if (this.useSystemClassLoader != null && ForkConfiguration.FORK_NEVER.equals(this.forkMode)) {
    	
      getLog().warn("useSystemClassloader setting has no effect when not forking");
      
    }

    return true;
    
  }
  
}
